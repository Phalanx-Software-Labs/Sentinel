================================================================================
SENTINEL — PHASE 1: FIRST WORKING VERSION
================================================================================
Goal: One working model to validate the idea. Quick check only. No full scan.
Assume high-quality large cards only.
================================================================================


--------------------------------------------------------------------------------
1. IN SCOPE
--------------------------------------------------------------------------------
- Standalone Sentinel app (no host integration).
- Drive selection: List available drives (e.g. Windows letters); user picks one.
- "Run quick check" button: Single on-demand action.
- Quick check behavior:
  - Create temp folder on selected drive (unique path per run, e.g. date/random).
  - Write N files (e.g. 5–10) whose total size = 10% of drive capacity, capped
    by free space. Use high-quality large card assumption (no special handling
    for small/full cards).
  - Fill each file with random data; compute hash (e.g. SHA-256) per file.
  - Read each file back twice; hash each read. Pass only if both reads match
    the original hash (and each other).
  - Delete temp folder and all test files.
- Result: Pass or fail. On fail: short message (e.g. "Integrity check failed").
- Optional: Show a lower-end confidence estimate (e.g. "~40%") with one-line
  disclaimer that this tests only part of the card and backups are essential.
- Progress: Simple progress or "Running…" during check.
- Config: Persist selected drive (and optionally check size %) in a small config
  file (e.g. JSON in user/app data directory).
- Use shutil.disk_usage for total/free to compute 10% and cap by free space.


--------------------------------------------------------------------------------
2. OUT OF SCOPE FOR PHASE 1
--------------------------------------------------------------------------------
- Full sweep (read all files + manifest, write/verify/delete all free space).
- Timestamp on card and "only run full sweep if X days elapsed".
- Manifest build or verify.
- Quality detection, schedule recommendation, or interval settings.
- Support for low-quality or very small cards.
- Mimic or any other host integration.
- Packaging as .exe (can be runnable script for first version).


--------------------------------------------------------------------------------
3. DELIVERABLES
--------------------------------------------------------------------------------
- One runnable Sentinel application (e.g. Python script or small app).
- Single window: drive selector, "Run quick check" button, progress, result,
  optional confidence line.
- Config file for last-used drive (and optional %).
- No installer required for v1; run from source or single script.


--------------------------------------------------------------------------------
4. MODULE / FILE STRUCTURE (SUGGESTED)
--------------------------------------------------------------------------------
  sentinel/
    core.py         # Integrity check: write N files, hash, read 2×, compare, delete.
    drive.py        # List drives, disk_usage(path), cap size by free space.
    config.py       # Load/save config (drive, optional %).
  sentinel_ui.py    # Standalone UI: drive dropdown, button, progress, result.
  sentinel_main.py  # Entry point: load config, show window, run.
  requirements.txt # If needed (e.g. none if stdlib only).


--------------------------------------------------------------------------------
5. CORE LOGIC (core.py) — SUMMARY
--------------------------------------------------------------------------------
- quick_check(drive_root: str, size_fraction: float = 0.10) -> dict
  - Returns e.g. {"passed": bool, "message": str, "details": str (optional)}
  - Uses temp dir with unique name (e.g. SentinelCheck_<date>_<short_random>).
  - Computes size_bytes = min(size_fraction * total, free - safety_margin).
  - Splits into N files (e.g. 5–10); writes random bytes, stores hashes.
  - Reads each file twice; hashes each read; compares to stored hash.
  - On first mismatch or read error: return passed=False.
  - Deletes temp dir and all files before return.
- All I/O in one thread; UI can run progress in main thread or poll.


--------------------------------------------------------------------------------
6. DRIVE AND CONFIG (drive.py, config.py) — SUMMARY
--------------------------------------------------------------------------------
- get_available_drives() -> list of drive roots (e.g. ["C:\\", "G:\\"]).
- get_drive_usage(path) -> (total_bytes, free_bytes) via shutil.disk_usage.
- config: JSON with keys e.g. "last_drive", "check_size_fraction" (default 0.10).
  Path: e.g. user data dir / "Sentinel" / "sentinel_config.json".


--------------------------------------------------------------------------------
7. UI (sentinel_ui.py) — SUMMARY
--------------------------------------------------------------------------------
- Window: title "Sentinel" or "Sentinel — Standing vigil".
- Dropdown or list: available drives (from drive.get_available_drives()).
- Button: "Run quick check". On click: run core.quick_check(selected_drive)
  (in thread or async so UI stays responsive); show progress; on done show
  result (Pass/Fail) and optional "Estimated confidence: ~40%. Always keep backups."
- Optional: Label showing "Last check: —" (can add later when we persist last result).
- Load/save config for selected drive on startup/change.


--------------------------------------------------------------------------------
8. ENTRY POINT (sentinel_main.py)
--------------------------------------------------------------------------------
- Load config; open UI; run main loop. No CLI required for v1.


--------------------------------------------------------------------------------
9. TESTING
--------------------------------------------------------------------------------
- Run on Windows with one high-capacity SD (or volume). Verify: quick check
  passes when card is good; optionally simulate failure (e.g. full disk, or
  manual test with bad path) to see fail path. No automated test suite
  required for first version; manual validation only.


--------------------------------------------------------------------------------
10. ESTIMATE
--------------------------------------------------------------------------------
- Implementation: ~2 days focused work to code-complete.
- Testing at end: manual run on real drive; fix any blocking issues.
- No full scan, no Mimic, high-quality large cards only.


================================================================================
END OF DOCUMENT — PHASE 1
================================================================================
